{-

   To Do List:
   + Fix styling
   + Fix feedback
   + Make size of each panel consistent
   + Add in graph questions
   + unique values
-}


port module LinearEquation exposing (..)

import Array
import Browser
import Html exposing (..)
import Html.Attributes exposing (class, classList, id, name, src, style, title, type_)
import Html.Events exposing (onClick)
import Maybe exposing (withDefault)
import Random
import Svg
import Svg.Attributes



{-
   These ports get data in from Torus to initialize the exercise and then send
   data back to Torus to let it know that we're done.

   I have to use a port instead of flags because Torus doesn't get all the initialization
   data to my code quickly enough.
-}


port getFromTorus : (Flags -> msg) -> Sub msg


port sendToTorus : Bool -> Cmd msg



{-
   The Answer type is used to specify what response is generated by each button. It answer the question
   "If they press button A then what answer are they are giving to the question?" I also need this type
   to specify what should be displayed on each button in a multiple choice question.

   The Choice type is used to specify the options being presented to the user. Each Choice corresponds
   to a different button in a multiple choice question.
-}


type Answer
    = NumberChoice Int -- when the answers are a single number (e.g., what's the slope?)
    | LineGraphChoice String Int Int -- when the answer is a graph of an equation (name, slope, y-intercept)
    | NoChoice


type alias Choice =
    { answer : Answer
    , feedback : String
    }


emptyChoice : Choice
emptyChoice =
    { answer = NoChoice, feedback = "Empty Feedback" }



{-
    I use RandomOrder to randomize the order of the buttons in the multiple choice questions. This is not
    an especially elegant solution, because it assumes there are always three choices. Since there are only
    three things to be randomized, there are only six total random orders. This means I can pick one random
    number between one and six to decide what random order to use.

   To randomize the order of questions, here's what I did:
   * The choices array is always in the same order: right answer, distractor 1, distractor 2
   * The randomOrder record has three fields: first, second and third
       * The first field gives an index from 0 to 2, that index tells you what item in the choices array was displayed in the first button
       * The second field gives an index from 0 to 2, that index tells you what item in the choices array was displayed in the second button
       * The third field gives an index from 0 to 2, that index tells you what item in the choices array was displayed in the third button
-}


type alias RandomOrder =
    { first : Int
    , second : Int
    , third : Int
    }


defaultOrder : RandomOrder
defaultOrder =
    { first = 1, second = 2, third = 3 }


getRandomOrder : Int -> RandomOrder
getRandomOrder randomOrder =
    case randomOrder of
        0 ->
            { first = 0, second = 1, third = 2 }

        1 ->
            { first = 0, second = 2, third = 1 }

        2 ->
            { first = 1, second = 0, third = 2 }

        3 ->
            { first = 1, second = 2, third = 0 }

        4 ->
            { first = 2, second = 0, third = 1 }

        _ ->
            { first = 2, second = 1, third = 0 }


getIndex : RandomOrder -> Int -> Int
getIndex randomOrder x =
    if x == randomOrder.first then
        0

    else if x == randomOrder.second then
        1

    else
        2



{-
   This defines the different types of questions I can generate
-}


type QuestionType
    = WhatIsTheSlope -- Given this equation, what is the slope?
    | WhatIsTheIntercept -- Given this equation, what is the y-intercept?
    | WhatIsY -- Given this equation and value for x, what is the value for y?
    | WhichGraph -- Which graph corresponds to this equation?



{-
   This defines a single question that will be presented to the user.

   The choices member is an array so I can randomly access each item based on the randomOrder list.
-}


type alias Question =
    { questionType : QuestionType -- What question will I present to the user?
    , slope : Int -- What is the slope of the line?
    , yIntercept : Int -- What is the y-intercept of the line?
    , xValue : Int -- What x value am I using?
    , choices : Array.Array Choice -- right choice, wrong choice 1, wrong choice 2
    , randomOrder : RandomOrder -- first button has choice <x>, second button has choice <y>, third button has choice <z>
    }


emptyQuestion : Question
emptyQuestion =
    { questionType = WhatIsTheSlope
    , slope = 0
    , yIntercept = 0
    , xValue = 0
    , choices = Array.empty
    , randomOrder = defaultOrder
    }



{-
   This is the model for the state. I keep the question in here along with keeping track of
   the user's response to the question being asked, how many questions the user has gotten
   right, and the number of questions the user is supposed to be asked.
-}


type alias Model =
    { question : Question -- What question do we show to the user?
    , userChoice : Int -- Which button did user choose? (1, 2 or 3)
    , progress : List RightOrWrong -- How many questions has the user gotten right/wrong?
    , status : Status -- What should we be showing to the user?
    , threshold : Int -- How many questions does the user need to get right?
    , window : Int -- How big is the window for reaching the threshold?
    , debug : Bool -- Do we show debug information?
    }


type RightOrWrong
    = RightAnswer -- user chose the correct answer
    | WrongAnswer -- user chose the wrong answer
    | NothingYet -- this is used by progress bar when the window is bigger than the number of responses


type Status
    = WaitingToStart -- user needs to ask for next question
    | WaitingForAnswer -- user needs to choose an answer
    | GotAnswer -- user has answered, so now we need to give feedback


initialModel : Model
initialModel =
    { question = emptyQuestion
    , userChoice = 0
    , progress = List.repeat 6 NothingYet
    , status = WaitingToStart
    , threshold = 4
    , window = 6
    , debug = True
    }



{-
   I use this to hold randomly-generated values for the question. It's not part of the model because I
   randomly generate integers and then change them into the types of things I want in the model.
-}


type alias QuestionParameters =
    { whatQuestion : Int -- What kind of question will be asked?
    , slope : Int -- What's the slope of the line?
    , yIntercept : Int -- What's the y-intercept?
    , xValue : Int -- What's the x-value?
    , randomOrder : Int -- What order should we present items?
    }



{-
    See the update function documentation.

   Flags is used to get data in from Torus
-}


type Msg
    = GetNextQuestion -- Generate random numbers for the next question
    | GotRandomQuestionParameters QuestionParameters -- Make sure random numbers produce unique values for all questions
    | GotRandomQuestion Question -- Use random numbers to create and display next question
    | GotResponse Int -- Give feedback to user about their answer
    | ReturnToTorus -- The user reached the threshold, go back to Torus (send to JavaScript)
    | GetDataFromTorus Flags -- Data coming in from Torus (get from JavaScript)


type alias Flags =
    { threshold : Int -- User needs to get <threshold> questions right...
    , window : Int -- out of the last <window> questions
    , debug : Bool -- True when we should show debug info
    }



{-
   The view consists of five stacked panels. I only display/update the panels that I need to at any given time.

   I use the status member of the model to determine which panels get displayed.
-}


view : Model -> Html Msg
view model =
    div []
        [ h1 [] [ text "Linear Equations" ]
        , viewQuestionPanel model
        , viewFeedbackPanel model
        , viewButtonPanel model
        , viewProgressPanel model
        , viewDebugPanel model
        ]



{-
   The question panel displays the question text. The question always starts with "If this is your equation..."

   When I am showing graphs to the user then the question panel gets split into two sub-panels (divs), one for
   text and one for the graphs.
-}


questionPanelStyle : List (Attribute msg)
questionPanelStyle =
    [ style "padding" "5px"
    , style "width" "800px"
    , style "height" "270px"
    ]


viewQuestionPanel : Model -> Html Msg
viewQuestionPanel model =
    case model.status of
        WaitingToStart ->
            div (id "questionPanel" :: questionPanelStyle)
                []

        WaitingForAnswer ->
            div (id "questionPanel" :: questionPanelStyle)
                [ text "If this is your equation:"
                , div [ id "questionText" ]
                    [ h3 [] [ text (equationAsString model.question.slope model.question.yIntercept) ]
                    , questionText model
                    ]
                ]

        GotAnswer ->
            -- div (id "questionPanel" :: questionPanelStyle)
            --     []
            div (id "questionPanel" :: questionPanelStyle)
                [ text "If this is your equation:"
                , div [ id "questionText" ]
                    [ h3 [] [ text (equationAsString model.question.slope model.question.yIntercept) ]
                    , questionText model
                    ]
                ]


equationAsString : Int -> Int -> String
equationAsString slope yIntercept =
    let
        operator =
            if yIntercept < 0 then
                "- "

            else
                "+ "
    in
    "y = "
        ++ String.fromInt slope
        ++ "x "
        ++ operator
        ++ String.fromInt (abs yIntercept)


questionText : Model -> Html Msg
questionText model =
    case model.question.questionType of
        WhatIsTheSlope ->
            text "What is the slope?"

        WhatIsTheIntercept ->
            text "What is the y-intercept?"

        WhichGraph ->
            whichGraphQuestion model

        WhatIsY ->
            text ("If x = " ++ String.fromInt model.question.xValue ++ " what does y equal?")


whichGraphQuestion : Model -> Html Msg
whichGraphQuestion model =
    div [ id "graphQuestion" ]
        [ text "Which graph corresponds to this equation?"
        , div [ id "graphPanel" ]
            [ drawGraph 0 model "A"
            , drawGraph 1 model "B"
            , drawGraph 2 model "C"
            ]
        ]



{-
   The feedback panel is where I tell the user whether they got the question right or wrong.

   Ideally, I also give the user feedback specific to their response that explains *why* their answer is wrong
   instead of just saying "Nope, that's wrong"
-}


feedbackPanelStyle : List (Attribute msg)
feedbackPanelStyle =
    [ style "padding" "5px"
    , style "width" "600px"
    , style "height" "30px"
    , style "vertical-align" "middle"
    , style "border-style" "solid"
    ]


viewFeedbackPanel : Model -> Html Msg
viewFeedbackPanel model =
    case model.status of
        WaitingToStart ->
            div (id "feedbackPanel" :: feedbackPanelStyle)
                []

        WaitingForAnswer ->
            div (id "feedbackPanel" :: feedbackPanelStyle)
                []

        GotAnswer ->
            div (id "feedbackPanel" :: feedbackPanelStyle)
                [ text (extractFeedback model) ]


extractFeedback : Model -> String
extractFeedback model =
    let
        index =
            getIndex model.question.randomOrder model.userChoice
    in
    model.question.choices
        |> Array.get index
        |> withDefault emptyChoice
        |> .feedback



{-
   The button panel shows the three possibe responses to the question that has been asked.
-}


buttonPanelStyle : List (Attribute msg)
buttonPanelStyle =
    [ style "border-radius" "5px"
    , style "padding" "5px"
    , style "width" "600px"
    , style "height" "50px"
    ]


answerButtonStyle : List (Attribute msg)
answerButtonStyle =
    [ style "border-radius" "5px"
    , style "padding" "5px"
    , style "width" "40px"
    , style "height" "40px"
    , style "display" "inline"
    ]


viewButtonPanel : Model -> Html Msg
viewButtonPanel model =
    case model.status of
        WaitingToStart ->
            div (id "buttonPanel" :: buttonPanelStyle)
                [ button
                    [ onClick GetNextQuestion ]
                    [ text "Start" ]
                ]

        WaitingForAnswer ->
            div (id "buttonPanel" :: buttonPanelStyle)
                [ button
                    (onClick (GotResponse 0) :: answerButtonStyle)
                    [ text (extractAnswer 0 model) ]
                , button
                    (onClick (GotResponse 1) :: answerButtonStyle)
                    [ text (extractAnswer 1 model) ]
                , button
                    (onClick (GotResponse 2) :: answerButtonStyle)
                    [ text (extractAnswer 2 model) ]
                ]

        GotAnswer ->
            if crossedThreshold model then
                div (id "buttonPanel" :: buttonPanelStyle)
                    [ button
                        [ onClick ReturnToTorus ]
                        [ text "Return to Torus" ]
                    ]

            else
                div (id "buttonPanel" :: buttonPanelStyle)
                    [ button
                        [ onClick GetNextQuestion ]
                        [ text "Click here to continue" ]
                    ]


crossedThreshold : Model -> Bool
crossedThreshold model =
    let
        sumRightAnswers =
            List.filter (\p -> p == RightAnswer) model.progress
                |> List.length
    in
    sumRightAnswers >= model.threshold


extractAnswer : Int -> Model -> String
extractAnswer buttonIndex model =
    let
        answerIndex =
            getIndex model.question.randomOrder buttonIndex

        answer =
            model.question.choices
                |> Array.get answerIndex
                |> withDefault emptyChoice
                |> .answer
    in
    case answer of
        NoChoice ->
            "No Choice"

        NumberChoice numberAnswer ->
            String.fromInt numberAnswer

        LineGraphChoice graphName _ _ ->
            String.fromChar (Char.fromCode (65 + buttonIndex))



{-
   To demonstrate mastery, the user must answer <threshold> questions out of the last <window> asked.

   The progress panel shows a total of <window> squares colored gray. As the user answers questions,
   the squares change to green (for correct answers) or red (for incorrect answers). As the user
   continues to answer questions, the colors "move" from left to right so that the result of the
   most recent response is always the first square.
-}


progressPanelStyle : List (Attribute msg)
progressPanelStyle =
    [ style "border-radius" "5px"
    , style "padding" "5px"
    , style "width" "600px"
    , style "height" "50px"
    ]


progressBarStyle : List (Attribute msg)
progressBarStyle =
    [ style "border-radius" "5px"
    , style "padding" "5px"
    , style "width" "10px"
    , style "height" "10px"
    , style "display" "inline-block"
    ]


progressBox : RightOrWrong -> Html Msg
progressBox rOrW =
    if rOrW == RightAnswer then
        div (style "background-color" "green" :: progressBarStyle) []

    else if rOrW == WrongAnswer then
        div (style "background-color" "red" :: progressBarStyle) []

    else
        div (style "background-color" "grey" :: progressBarStyle) []


viewProgressPanel : Model -> Html Msg
viewProgressPanel model =
    if model.status == WaitingToStart then
        div (id "progressPanel" :: progressPanelStyle)
            []

    else
        let
            progressBar =
                List.reverse model.progress
                    |> List.map progressBox
        in
        div
            (id "progressPanel" :: progressPanelStyle)
            progressBar



{-
   I use the debug panel to look at values in the program
-}


viewDebugPanel : Model -> Html Msg
viewDebugPanel model =
    if model.debug then
        div [ id "debugPanel" ]
            [ text ("threshold: " ++ String.fromInt model.threshold)
            , text ("window: " ++ String.fromInt model.window)
            ]

    else
        div [ id "debugPanel" ] []



{-
   All of these functions return a Question record that has the appropriate values filled in.
-}


makeQuestion : QuestionParameters -> Question
makeQuestion questionParameters =
    case questionParameters.whatQuestion of
        0 ->
            whatIsTheSlopeQuestion questionParameters

        1 ->
            whatIsTheInterceptQuestion questionParameters

        2 ->
            whatIsYQuestion questionParameters

        3 ->
            whatIsGraphQuestion questionParameters

        _ ->
            whatIsTheSlopeQuestion questionParameters


whatIsTheInterceptQuestion : QuestionParameters -> Question
whatIsTheInterceptQuestion qp =
    let
        choices =
            Array.fromList
                [ { answer = NumberChoice qp.yIntercept, feedback = "Correct! The y-intercept is " ++ String.fromInt qp.yIntercept }
                , { answer = NumberChoice qp.slope, feedback = "That's the slope. The y-intercept is " ++ String.fromInt qp.yIntercept }
                , { answer = NumberChoice qp.xValue, feedback = "That is incorrect. The y-intercept is " ++ String.fromInt qp.yIntercept }
                ]
    in
    { questionType = WhatIsTheIntercept
    , slope = qp.slope
    , yIntercept = qp.yIntercept
    , xValue = qp.xValue
    , choices = choices
    , randomOrder = getRandomOrder qp.randomOrder
    }


whatIsTheSlopeQuestion : QuestionParameters -> Question
whatIsTheSlopeQuestion qp =
    let
        choices =
            Array.fromList
                [ { answer = NumberChoice qp.slope, feedback = "Correct! The slope is " ++ String.fromInt qp.slope }
                , { answer = NumberChoice qp.yIntercept, feedback = "That's the y-intercept. The slope is " ++ String.fromInt qp.slope }
                , { answer = NumberChoice qp.xValue, feedback = "That is incorrct. The slope is " ++ String.fromInt qp.slope }
                ]
    in
    { questionType = WhatIsTheSlope
    , slope = qp.slope
    , yIntercept = qp.yIntercept
    , xValue = qp.xValue
    , choices = choices
    , randomOrder = getRandomOrder qp.randomOrder
    }


whatIsYQuestion : QuestionParameters -> Question
whatIsYQuestion qp =
    let
        yValue =
            qp.slope * qp.xValue + qp.yIntercept

        choices =
            Array.fromList
                [ { answer = NumberChoice yValue, feedback = "Correct! The value of y is " ++ String.fromInt yValue }
                , { answer = NumberChoice qp.yIntercept, feedback = "That is the y-intercept. The value of y is " ++ String.fromInt yValue }
                , { answer = NumberChoice (qp.yIntercept * qp.xValue + qp.slope), feedback = "That is incorrect. The value of y is " ++ String.fromInt yValue }
                ]
    in
    { questionType = WhatIsY
    , slope = qp.slope
    , yIntercept = qp.yIntercept
    , xValue = qp.xValue
    , choices = choices
    , randomOrder = getRandomOrder qp.randomOrder
    }


whatIsGraphQuestion : QuestionParameters -> Question
whatIsGraphQuestion qp =
    let
        choices =
            Array.fromList
                [ { answer = LineGraphChoice "Correct" qp.slope qp.yIntercept, feedback = "Correct!" }
                , { answer = LineGraphChoice "wrong slope" (qp.slope * -1) qp.yIntercept, feedback = "That is incorrect. That graph shows a line with the wrong slope" }
                , { answer = LineGraphChoice "wrong y-intercept" qp.slope (qp.yIntercept * -1), feedback = "That is incorrect. That graph shows a line with the wrong y-intercept" }
                ]
    in
    { questionType = WhichGraph
    , slope = qp.slope
    , yIntercept = qp.yIntercept
    , xValue = qp.xValue
    , choices = choices
    , randomOrder = getRandomOrder qp.randomOrder
    }



{-
   The hard part of generating questions is coming up with distractors that are believable but (1) wrong,
   (2) different from the correct answer and (3) different from each other. The goodValues function checks
   whether the values that were randomly chosen fulfill that criteria. If the values are good, then the
   program can go on and generate the question. If the values aren't good then it picks new random values.
-}


goodValues : Int -> Int -> Int -> Bool
goodValues slope yIntercept xValue =
    -- get yValue
    let
        yValue =
            slope * xValue + yIntercept

        yValueWrong =
            yIntercept * xValue + slope
    in
    if slope == 0 || slope == yIntercept || slope == yValue || slope == xValue || slope == yValueWrong then
        False
        -- if slope = yValue then change yIntercept

    else if yIntercept == 0 || yIntercept == xValue || yIntercept == yValue || yIntercept == yValueWrong then
        False

    else if xValue == yValue || xValue == yValueWrong then
        False

    else if yValue == yValueWrong then
        False

    else
        True


questionParametersGenerator : Random.Generator QuestionParameters
questionParametersGenerator =
    Random.map5
        QuestionParameters
        -- what kind of question
        (Random.int 0 3)
        -- random slope
        (Random.int -3 3)
        -- random yIntercept
        (Random.int -8 8)
        -- random xValue
        (Random.int 1 10)
        -- random order to display choices
        (Random.int 0 5)



{-
   The flow for this program:
   * Initialize the exercise
       * GetDataFromTorus
   * Make a question
       * GetNextQuestion
       * GotRandomQuestionParameters
           - If the numbers combine to make unique answers -> GotRandomQuestion
           - Otherwise -> GetNextQuestion
   * Present the question and wait for a response
   * Evaluate whether they got it right
       * GotResponse
           - If they are done, then send control back to Torus -> ReturnToTorus
           - Otherwise, get the next question -> GetNextQuestion
-}


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        -- Choose random values for the next question
        GetNextQuestion ->
            ( { model | status = WaitingForAnswer }
            , Random.generate GotRandomQuestionParameters questionParametersGenerator
            )

        -- We got random values, if the values result in three unique choices for the multiple
        -- choice question, then go ahead and make the question. Otherwise, go back and pick
        -- new random values.
        GotRandomQuestionParameters qp ->
            if goodValues qp.slope qp.yIntercept qp.xValue then
                update
                    (GotRandomQuestion (makeQuestion qp))
                    model

            else
                update GetNextQuestion model

        -- Display the new question and wait for the user to answer
        GotRandomQuestion newQuestion ->
            ( { model
                | question = newQuestion
                , status = WaitingForAnswer
              }
            , Cmd.none
            )

        -- The user answered the question. Update the progress bar based on whether they got the
        -- question right or wrong and then update the display.
        GotResponse userChoice ->
            ( { model
                | progress = updateProgress model.window model.progress model.question.randomOrder.first userChoice
                , status = GotAnswer
                , userChoice = userChoice
              }
            , Cmd.none
            )

        -- The user has demonstrated mastery, kick control back to Torus
        ReturnToTorus ->
            ( model, sendToTorus True )

        -- Data to initialize the exercise has come in from Torus.
        GetDataFromTorus flags ->
            ( { model
                | threshold = flags.threshold
                , window = flags.window
                , debug = flags.debug
                , progress = List.repeat flags.window NothingYet
              }
            , Cmd.none
            )


updateProgress : Int -> List RightOrWrong -> Int -> Int -> List RightOrWrong
updateProgress window oldRWs rightAnswer userAnswer =
    let
        newRW =
            if rightAnswer == userAnswer then
                RightAnswer

            else
                WrongAnswer

        newRWs =
            List.append oldRWs [ newRW ]

        countRWs =
            List.length newRWs
    in
    List.drop (countRWs - window) newRWs


initialCmd : Cmd Msg
initialCmd =
    Cmd.none


init : () -> ( Model, Cmd Msg )
init _ =
    ( initialModel
    , initialCmd
    )


subscriptions : Model -> Sub Msg
subscriptions _ =
    getFromTorus GetDataFromTorus


main : Program () Model Msg
main =
    Browser.element
        { init = init
        , view = view
        , update = update
        , subscriptions = subscriptions
        }



{-
   This code is for drawing graphs.
-}


canvasHeight : Int
canvasHeight =
    150


canvasWidth : Int
canvasWidth =
    200


maxX : Int
maxX =
    20


minX : Int
minX =
    0


maxY : Int
maxY =
    50


minY : Int
minY =
    -50


intervalX : Int
intervalX =
    (canvasWidth - (2 * graphPadding)) // (maxX - minX)


intervalY : Int
intervalY =
    (canvasHeight - (2 * graphPadding)) // (maxY - minY)


graphPadding : Int
graphPadding =
    5


graphOrigin : ( Int, Int )
graphOrigin =
    ( graphPadding
    , canvasHeight // 2
    )


graphOriginString : ( String, String )
graphOriginString =
    ( String.fromInt (Tuple.first graphOrigin)
    , String.fromInt (Tuple.second graphOrigin)
    )


toCanvasCoordinates : ( Int, Int ) -> ( Int, Int )
toCanvasCoordinates ( x, y ) =
    ( toCanvasX x
    , toCanvasY y
    )


toCanvasX : Int -> Int
toCanvasX x =
    Tuple.first graphOrigin + (x * intervalX)


toCanvasY : Int -> Int
toCanvasY y =
    Tuple.second graphOrigin - (y * intervalY)


toCanvasXString : Int -> String
toCanvasXString x =
    toCanvasX x
        |> String.fromInt


toCanvasYString : Int -> String
toCanvasYString y =
    toCanvasY y
        |> String.fromInt


drawGraph : Int -> Model -> String -> Html msg
drawGraph graphIndex model name =
    let
        answerIndex =
            getIndex model.question.randomOrder graphIndex

        answer =
            model.question.choices
                |> Array.get answerIndex
                |> withDefault emptyChoice
                |> .answer
    in
    div [ style "display" "inline-block" ]
        [ div [ style "display" "block" ]
            [ Svg.svg
                [ Svg.Attributes.width (String.fromInt canvasWidth)
                , Svg.Attributes.height (String.fromInt canvasHeight)

                --, Svg.Attributes.viewBox "0 0 200 200"
                , Html.Attributes.style "border-width" "2px"
                , Html.Attributes.style "border-style" "solid"
                , Html.Attributes.style "border-color" "black"
                ]
                (drawLine answer :: drawAxes)
            ]
        , div
            [ style "display" "block"
            , style "text-align" "center"
            ]
            [ text name ]
        ]


drawAxes : List (Svg.Svg msg)
drawAxes =
    [ Svg.line
        [ Svg.Attributes.x1 (toCanvasXString 0)
        , Svg.Attributes.y1 (String.fromInt graphPadding)
        , Svg.Attributes.x2 (toCanvasXString 0)
        , Svg.Attributes.y2 (String.fromInt (canvasHeight - graphPadding))
        , Svg.Attributes.stroke "black"
        ]
        []
    , Svg.line
        [ Svg.Attributes.x1 (toCanvasXString 0)
        , Svg.Attributes.y1 (toCanvasYString 0)
        , Svg.Attributes.x2 (toCanvasXString maxX)
        , Svg.Attributes.y2 (toCanvasYString 0)
        , Svg.Attributes.stroke "black"
        ]
        []
    ]


drawLine : Answer -> Svg.Svg msg
drawLine answer =
    case answer of
        LineGraphChoice _ slope yIntercept ->
            let
                x1 =
                    0

                x2 =
                    maxX

                y1 =
                    slope * x1 + yIntercept

                y2 =
                    slope * x2 + yIntercept
            in
            Svg.line
                [ Svg.Attributes.x1 (toCanvasXString x1)
                , Svg.Attributes.y1 (toCanvasYString y1)
                , Svg.Attributes.x2 (toCanvasXString x2)
                , Svg.Attributes.y2 (toCanvasYString y2)
                , Svg.Attributes.stroke "black"
                ]
                []

        _ ->
            Svg.line
                [ Svg.Attributes.x1 (toCanvasXString 0)
                , Svg.Attributes.y1 (toCanvasYString 0)
                , Svg.Attributes.x2 (toCanvasXString 0)
                , Svg.Attributes.y2 (toCanvasYString 0)
                , Svg.Attributes.stroke "black"
                ]
                []
